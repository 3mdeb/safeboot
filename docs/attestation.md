# TPM2 Remote Attestation
![TPM on a server mainboard](images/tpm-header.jpg)

When the user wants to connect to another computer over the network,
they typicaly authenticate with a password and some sort of two factor
token to prove to the remote system that they are authorized to
make the connection.  In high assurance applications, however, it is
also important that the local computer be able to attest to the remote
server that the local computer itself is both authorized and is also
in a known configuration.

The TPM provides a mechanism to do this sort of remote attestation,
similar to the way that the disk encryption keys are "sealed" based
on the PCRs and only decrypted if the platform configuration matches
the sealed values.  The `tpm2-tools` package has many of the pieces,
but it is at too low a level for humans to use.  Other parts of the
validation exist in the `openssl` package, but again are not easily
used and require format conversions from the TPM formats.

`tpm2-attest` attempts to wrap all of the various parts of
those two packages into a simple script that provides the four
main attestation functions: sign a quote, validate a signed quote,
seal a secret for a specific TPM, and unseal it with that TPM.

## tl;dr

* Client: Get `$nonce` and `$pcrs` from server
* Client: `tpm2-attest $nonce $pcrs > quote.tgz`
* Client: Send `quote.tgz` to server
* Server: `tpm2-attest validate quote.tgz $nonce`
* Server: `tpm2-attest seal quote.tgz < secret.txt > cipher.bin`
* Server: Send `cipher.bin` to client
* Client: `tpm2-attest unseal < cipher.bin > secret.txt`
* Client: Use `secret.txt` to whatever

## Attestation overview

The protocol requires a few round-trips between the local machine (the client)
and the remote attestation machine (the server), although none of the information
in the messages is sensitive - the `quote.tgz` file contains only public keys
and PCR values that should be considered public, and the `cipher.bin` reply
is encrypted with the TPM's endorsement key, so it should only be unsealable by
that specific TPM.

The keys involved are:

* CA Root, stored hopefully securely by the CA
* TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM
* TPM Endorsement key (`EK`), an encryption key, generated in the TPM(?) and stored in the TPM hardware device
* TPM Endorsement certificate (`ek.crt`), signed by the TPM manufacturer, often stored in the TPM NVRAM
* Attestation Key (`AK`), a signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes

The protocol between the client and the server goes in four phases: communication initiation, quote signing, quote validation, and secret sealing

### Initiation

* Client contacts the attestation server, requests a nonce that is used to prevent reply attacks, and the list of PCRs to be signed.
* Server sends the nonce (in the clear is fine, since it is literally a random number)

### Quote signing
```
tpm2-attest quote $nonce $pcrs > quote.tgz
```

With this command the client machine will:

* Extracts the public part of the TPM Endorsement Key and the x509 certificate signed by the TPM manufacturer
* Generates a signing-only Attestation Key (`AK`) inside the TPM and exports the public key (`ak.pub`)
* Uses the TPM to sign a "quote" of the requested PCRs plus the nonce with the Attestation Key
* Extract the TPM event log and IMA event log, if they are available
* Bundle up all of the pieces into a tar file: `ek.crt`, `ek.pub`, `ak.pub`, `quote.sig`, `quote.pcr`, `quote.msg`, `eventlog` and the `nonce`

The Client then sends this quote file to the Server.

### Quote validation
When the Server receives the quote file from the client, it runs:
```
tpm2-attest validate quote.tgz $nonce
```

With this command the server will:

* Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM
* Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client)
* Server optionally consults its list of approved devices to verify that this EK is in an owner controlled machine
* Server optionally validates that the PCRs match the expected values
* Server optoinally validates that the TPM event log produces the set of
PCR values in the quote

If the command fails, then something is likely wrong on the Client side
and requires remediation.  The Server should not proceed to sealing a
secret for the Client.

### Secret sealing

Assuming the validation passed, the server can seal secret data such
that only the TPM that produced the signed attestation will be able to
unseal it, and has faith that the TPM will not unseal it if it has been
reset (to prevent attacks that reboot into untrusted firmware):

```
cat secret.txt | tpm2-attest seal quote.tgz > cipher.bin
```

With this command the Server will:

* Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK.

The Server then sends this encrypted blob to the Client.

### Secret unsealing
Once the Client receives the sealed blob from the Server, it attempts
to unseal it with the Attestation Key context that is left over from the
initial quote signing:

```
cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt
```

With this command, the Client and TPM will:

* Initiates an encrypted session with the TPM and sends the blob to it.
* The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob.
* Client receives the secret message over the encrypted channel to the TPM

At this point the Client can use the shared secret to authenticate to
the Server, a network, or decrypt it's disk, or whatever.  The TPM is
no longer involved.

Some notes:

* Generating an AK each time is not necessary; one could be pregenerated and persistent in the TPM, although that requires additoinal setup.
* The AK is not signed by the EK, so the Server has to trust that the EK is stored inside of a real TPM and that
the real TPM will not decrypt the message unless the AK matches. I think, this part of `tpm2_makecredential` is
totally undocumented in the man page.
* Not all TPMs store their EK certs in the NVRAM; some of them require a query to the OEM.
* The CA Root Certs and OEM intermediate Certs are not well documented; a complete collection needs to be built.
* The Server does not require any TPM interaction at all -- all of its work is done in software.
* The secret session for unsealing the blob provides protection against a passive adversary snooping on the LPC bus, although an active attacker with hardware on the LPC bus can interfere with the PCR extensions and generate quotes with untrustworthy PCRs.

## TPM OEM Certificates

TODO: catalog a list of them and how to maintain the `/path/to/certs`

The `/etc/safeboot/refresh-certs` will use its list of OEM certificate URLs
to rebuild the CA directory in `/etc/safeboot/certs/`.
