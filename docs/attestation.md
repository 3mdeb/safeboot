---
title: "tpm2-attest: TPM2 Remote Attestation"
summary: >-
  tpm2-attest is a simple way to have an untrusted Linux machine
  generate signed TPM quotes, validate those quotes and endorsement keys
  on a remote attestation server, and seal a secret message that will
  only be unsealable on that specific TPM.
image: "images/tpm-header.jpg"
---

![TPM on a server mainboard](images/tpm-header.jpg)

When the user wants to connect to another computer over the network,
they typicaly authenticate with a password and some sort of two factor
token to prove to the remote system that they are authorized to
make the connection.  In high assurance applications, however, it is
also important that the local computer be able to attest to the remote
server that the local computer itself is both authorized and is also
in a known configuration.

The TPM provides a mechanism to do this sort of remote attestation,
similar to the way that the disk encryption keys are "sealed" based
on the PCRs and only decrypted if the platform configuration matches
the sealed values.  The `tpm2-tools` package has many of the pieces,
but it is at too low a level for humans to use.  Other parts of the
validation exist in the `openssl` package, but again are not easily
used and require format conversions from the TPM formats.

`tpm2-attest` attempts to wrap all of the various parts of
those two packages into a simple script that provides the four
main attestation functions: sign a quote, validate a signed quote,
seal a secret for a specific TPM, and unseal it with that TPM.

## tl;dr

* Client: Get `$nonce` and `$pcrs` from server
* Client: `tpm2-attest $nonce $pcrs > quote.tgz`
* Client: Send `quote.tgz` to server
* Server: `tpm2-attest verify-and-seal quote.tgz $nonce < secret.txt > cipher.bin`
* Server: Send `cipher.bin` to client
* Client: `tpm2-attest unseal < cipher.bin > secret.txt`
* Client: Use `secret.txt` to decrypt disk, authenticate to network, etc

## Attestation protocol

The protocol requires a few round-trips between the local machine (the client)
and the remote attestation machine (the server), although none of the information
in the messages is sensitive - the `quote.tgz` file contains only public keys
and PCR values that should be considered public, and the `cipher.bin` reply
is encrypted with the TPM's endorsement key, so it should only be unsealable by
that specific TPM.

The keys involved are:

* CA Root, stored hopefully securely by the CA
* TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM
* TPM Endorsement key (`EK`), an encryption key, generated in the TPM(?) and stored in the TPM hardware device
* TPM Endorsement certificate (`ek.crt`), signed by the TPM manufacturer, often stored in the TPM NVRAM
* Attestation Key (`AK`), a signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes

The protocol between the client and the server goes in four phases: communication initiation, quote signing, quote validation, and secret sealing

### Initiation

* Client contacts the attestation server, requests a nonce that is used to prevent reply attacks, and the list of PCRs to be signed.
* Server sends the nonce (in the clear is fine, since it is literally a random number)

### Quote signing
```
tpm2-attest quote $nonce $pcrs > quote.tgz
```

With this command the client machine will:

* Extracts the public part of the TPM Endorsement Key and the x509 certificate signed by the TPM manufacturer
* Generates a signing-only Attestation Key (`AK`) inside the TPM and exports the public key (`ak.pub`)
* Uses the TPM to sign a "quote" of the requested PCRs plus the nonce with the Attestation Key
* Extract the TPM event log and IMA event log, if they are available
* Bundle up all of the pieces into a tar file: `ek.crt`, `ek.pub`, `ak.pub`, `quote.sig`, `quote.pcr`, `quote.msg`, `eventlog` and the `nonce`

The Client then sends this quote file to the Server.

### Quote validation
When the Server receives the quote file from the client, it runs:
```
tpm2-attest verify quote.tgz $nonce
```

With this command the server will:

* Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM
* Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client)
* Server optionally consults its list of previously enrolled devices to verify that this EK is in an owner controlled machine
* Server optionally validates that the PCRs match the expected values
* Server optoinally validates that the TPM event log produces the set of
PCR values in the quote

If the command fails, then something is likely wrong on the Client side
and requires remediation.  The Server should not proceed to sealing a
secret for the Client.

### Secret sealing

Assuming the validation passed, the server can seal secret data such
that only the TPM that produced the signed attestation will be able to
unseal it, and has faith that the TPM will not unseal it if it has been
reset (to prevent attacks that reboot into untrusted firmware):

```
cat secret.txt | tpm2-attest seal quote.tgz > cipher.bin
```

With this command the Server will:

* Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK.

The Server then sends this encrypted blob to the Client.

Note that there is a `verify-and-seal` that combines both the quote validation
and the sealing of the data to the attestation key in one step:

```
cat secret.txt | tpm2-attest seal quote.tgz $nonce > cipher.bin
```

### Secret unsealing
Once the Client receives the sealed blob from the Server, it attempts
to unseal it with the Attestation Key context that is left over from the
initial quote signing:

```
cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt
```

With this command, the Client and TPM will:

* Initiates an encrypted session with the TPM and sends the blob to it.
* The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob.
* Client receives the secret message over the encrypted channel to the TPM

At this point the Client can use the shared secret to authenticate to
the Server, a network, or decrypt it's disk, or whatever.  The TPM is
no longer involved.

## Some notes

* All comunication between the Client and the Server can be in the clear.
There is no sensitive data exchanged and a MITM can only substitute
a different EK/AK pair; they are not able to masquarade as the TPM of
the attesting machine since they do not have the EK for that TPM.

* Suprisingly, the Attestation Key is not signed by the Endorsement Key,
so the Server has to check the EK certificate to ensure that it came from
a real TPM. Additional, the Server must check the AK attributes to ensure
that it has `fixedtpm` and `sensitivedataorigin` set, which indicates that
the AK was generated inside the TPM. Even with these checks, the Server is
still trusting that the TPM hardware implements `tpm2_activatecredential`
with all of these checks correctly done, since the sealed data is encrypted
with the EK, not the AK.  (Like many things with the TPM2, this is a really
baroque way to organize the keys).

* Generating an AK each time should not be necessary; one could be
pregenerated and persistent in the TPM, except that opens up a race
condition between generating a quote and receiving the sealed data.
The *quote* includes the reboot count, but the *sealed data* does not
reference it, so the TPM will unseal it if the AK is still valid.
By creating an ephemeral AK (with the `stclear` bit set in the
attributes), the TPM will not allow it to be persisted and will refuse
to load it when the reboot counter increments.

* Not all TPMs store their EK certs in the NVRAM; some of them require a query to the OEM.

* The Server does not require any TPM interaction at all -- all of its
work is done in software and can be run as an ordinary user.

* The Discrete TPM is a hardware weakpoint; a physically proximate adversary
could remove the TPM from a machine and connect it to an untrusted device and
then masquarade as the device to which the TPM had been connected.  This would
also potentially allow them to extract any sealed disk encryption keys,
[as described on the threat model page](threats.md), and is one of the
advantages of an fTPM inside the Management Engine.

* A proximate attacker could also interfere with the LPC or i2c bus of a Discrete TPM
using something like [the TPM Genie](https://www.nccgroup.com/uk/our-research/tpm-genie/),
which allow them to both modify the hashes sent to the TPM during PCR extension operations,
and read the unsealed secrets when they are returned if the TPM didn't support
secret sessions.

## TPM OEM Certificates

TODO: catalog a list of them and how to maintain the `/path/to/certs`

The `/etc/safeboot/refresh-certs` will use its list of OEM certificate URLs
to rebuild the CA directory in `/etc/safeboot/certs/`.
